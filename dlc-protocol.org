* Notes
** Revocation key ignored for now
The DLC should be embedded in a revocable contract created by ~rust-lightning~.
** Generate signing keypairs
- ~(t, T)~
- ~(m, M)~
** Choose addresses for non-collaborative settlement
Pay back to the 10101 Bitcoin wallet!
** Build and encsign spend transactions
*** What we need from ~rust-lightning~
- Outpoint of the custom output to create input.
- Custom output script code for sighash.
- Custom output amount for sighash.
* Protocol proposal
Assume channel is already open and with sufficient funds on both sides.
** Agree on CFD parameters (payouts, expiration date, etc.)
** Taker and maker exchange signing PKs, final Bitcoin addresses
** Taker calls ~add_custom_output~
*** Arguments
- Channel ID of channel with maker.
- Taker amount.
- Maker amount.
- Custom script including PKs ~T~ and ~M~.
*** Return
Commitment transaction details.
*** Modifications
At the moment we queue up a couple of messages when calling this, but we need to only do this once we've exchanged signatures on CETs and the refund transaction, which happens outside of ~rust-lightning~.
** Taker builds CETs and refund transaction based on commitment transaction
** Taker signs refund transaction and encsigns all CETs
** Taker sends over commitment transaction info, CET encsignatures and refund transaction signature
** Maker verifies all received data
The maker cannot do anything with this yet because they don't have the commitment transaction signature from the taker.
** Maker signs and sends back accordingly
** Taker tells ~rust-lightning~ to proceed with protocol
- Call it something like ~send_add_custom_output~.
- This will actually queue up the messages that were generated after calling ~add_custom_output~
** Taker's ~rust-lightning~ automatically sends ~update_add_custom_output~ message and ~commitment_signed~
The maker /must/ check that the custom output described in the message is the same one that they signed spend transactions for! This means the protocol should become interactive on the listener side.
** After the maker verifies the custom output, continue with the current ~rust-lightning~ protocol
* Protocol proposal v2
1. Taker add custom output -> (commitment_maker, commitment_taker).  --> called from outside
2. Taker build CETs_maker and encsigns them using commitment_maker.
3. Taker build CETs_taker and encsigns them using commitment_taker.
4. Taker sends CETs_maker and CETs_maker_encsigs_taker.
5. Taker sends CETs_taker and CETs_taker_encsigs_taker.
6. Taker sends msg::UpdateAddCustomOutput(add_custom_output_msg) to Maker --> called from outside
6.a. Maker receives AddCustomOutputRequest: bubbles up event
--- only proceed if maker received CETs from taker
7. Maker add custom output -> (commitment_taker, commitment_maker, commitment_m|taker_signature)  --> called from outside
8. Maker sends msg::UpdateAddCustomOutput(add_custom_output_msg, commitment_m|taker_signature) to Taker
9. Maker build CETs_maker and encsigns them using commitment_maker.
10. Maker build CETs_taker and encsigns them using commitment_taker.
11. Maker sends CETs_taker_encsigs_maker.
12. Maker sends CETs_maker_encsigs_maker.


Taker state
- LocalAddedCustomOutput: after 1 --> needs to bubble up an event
- RemoteCommitmentSignatureReceived
- LocalCommitmentSignatureSent
- RevokeAndAckSent
- RevokeAndAckReceived

Maker state
- ReceivedAddCustomOutputRequest: after 6 --> needs to bubble up an event
- LocalAddedCustomOutput
- LocalCommitmentSignatureSent
- RemoteCommitmentSignatureReceived
- RevokeAndAckReceived
- RevokeAndAckSent

Alpha
- LocalRemoved
- RemoteRemoved
- AwaitingRemoteToRevokeAfterRemoval

Beta
- LocalRemoved
- RemoteRemoved
- AwaitingRemoteToRevokeAfterRemoval